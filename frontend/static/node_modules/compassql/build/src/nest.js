"use strict";
var channel_1 = require("vega-lite/build/src/channel");
var util_1 = require("datalib/src/util");
var model_1 = require("./model");
var property_1 = require("./property");
var propindex_1 = require("./propindex");
var groupby_1 = require("./query/groupby");
var shorthand_1 = require("./query/shorthand");
var spec_1 = require("./query/spec");
/**
 * Registry for all possible grouping key functions.
 */
var groupRegistry = {};
/**
 * Add a grouping function to the registry.
 */
function registerKeyFn(name, keyFn) {
    groupRegistry[name] = keyFn;
}
exports.registerKeyFn = registerKeyFn;
exports.FIELD = 'field';
exports.FIELD_TRANSFORM = 'fieldTransform';
exports.ENCODING = 'encoding';
exports.TRANSPOSE = 'transpose';
exports.SPEC = 'spec';
/**
 * Group the input spec query model by a key function registered in the group registry
 * @return
 */
function nest(specModels, queryNest) {
    if (queryNest) {
        var rootGroup_1 = new model_1.SpecQueryModelGroup();
        var groupIndex_1 = {};
        // global `includes` and `replaces` will get augmented by each level's groupBy.
        // Upper level's `groupBy` will get cascaded to lower-level groupBy.
        // `replace` can be overriden in a lower-level to support different grouping.
        var includes_1 = [];
        var replaces = [];
        var replacers_1 = [];
        for (var l = 0; l < queryNest.length; l++) {
            includes_1.push(l > 0 ? includes_1[l - 1].duplicate() : new propindex_1.PropIndex());
            replaces.push(l > 0 ? replaces[l - 1].duplicate() : new propindex_1.PropIndex());
            var groupBy = queryNest[l].groupBy;
            if (util_1.isArray(groupBy)) {
                // If group is array, it's an array of extended group by that need to be parsed
                var parsedGroupBy = groupby_1.parseGroupBy(groupBy, includes_1[l], replaces[l]);
                replacers_1.push(parsedGroupBy.replacer);
            }
        }
        // With includes and replacers, now we can construct the nesting tree
        specModels.forEach(function (specM) {
            var path = '';
            var group = rootGroup_1;
            for (var l = 0; l < queryNest.length; l++) {
                var groupBy = group.groupBy = queryNest[l].groupBy;
                group.orderGroupBy = queryNest[l].orderGroupBy;
                var key = util_1.isArray(groupBy) ?
                    shorthand_1.spec(specM.specQuery, includes_1[l], replacers_1[l]) :
                    groupRegistry[groupBy](specM);
                path += '/' + key;
                if (!groupIndex_1[path]) {
                    groupIndex_1[path] = new model_1.SpecQueryModelGroup(key, path, []);
                    group.items.push(groupIndex_1[path]);
                }
                group = groupIndex_1[path];
            }
            group.items.push(specM);
        });
        return rootGroup_1;
    }
    else {
        // no nesting, just return a flat group
        return new model_1.SpecQueryModelGroup('', '', specModels);
    }
}
exports.nest = nest;
// TODO: move this to groupBy, rename properly, and export
var GROUP_BY_FIELD = [property_1.Property.FIELD];
var PARSED_GROUP_BY_FIELD = groupby_1.parseGroupBy(GROUP_BY_FIELD);
registerKeyFn(exports.FIELD, function (specM) {
    return shorthand_1.spec(specM.specQuery, PARSED_GROUP_BY_FIELD.include, PARSED_GROUP_BY_FIELD.replacer);
});
exports.PARSED_GROUP_BY_FIELD_TRANSFORM = groupby_1.parseGroupBy(groupby_1.GROUP_BY_FIELD_TRANSFORM);
registerKeyFn(exports.FIELD_TRANSFORM, function (specM) {
    return shorthand_1.spec(specM.specQuery, exports.PARSED_GROUP_BY_FIELD_TRANSFORM.include, exports.PARSED_GROUP_BY_FIELD_TRANSFORM.replacer);
});
exports.PARSED_GROUP_BY_ENCODING = groupby_1.parseGroupBy(groupby_1.GROUP_BY_ENCODING);
registerKeyFn(exports.ENCODING, function (specM) {
    return shorthand_1.spec(specM.specQuery, exports.PARSED_GROUP_BY_ENCODING.include, exports.PARSED_GROUP_BY_ENCODING.replacer);
});
function stringifyStack(specM) {
    var _stack = spec_1.stack(specM.specQuery);
    return (!!_stack ? 'stack=' + _stack.offset + '|' : '');
}
// TODO: rename, provide similar format
registerKeyFn(exports.TRANSPOSE, function (specM) {
    return specM.getMark() + '|' +
        stringifyStack(specM) +
        specM.getEncodings().map(function (encQ) {
            var fieldDef = shorthand_1.fieldDef(encQ);
            var channel = (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) ? 'xy' :
                (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) ? 'facet' :
                    encQ.channel;
            return channel + ':' + fieldDef;
        })
            .sort()
            .join('|');
});
registerKeyFn(exports.SPEC, function (specM) { return JSON.stringify(specM.specQuery); });
//# sourceMappingURL=nest.js.map