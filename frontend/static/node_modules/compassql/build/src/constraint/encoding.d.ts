import { AbstractConstraint, AbstractConstraintModel } from './base';
import { QueryConfig } from '../config';
import { SpecQueryModel } from '../model';
import { Property } from '../property';
import { PropIndex } from '../propindex';
import { Wildcard } from '../wildcard';
import { Schema } from '../schema';
import { FieldQuery, EncodingQueryBase, ValueQuery } from '../query/encoding';
/**
 * Collection of constraints for a single encoding mapping.
 */
/** A method for satisfying whether the provided encoding query satisfy the constraint. */
export interface EncodingConstraintChecker<E extends EncodingQueryBase> {
    (encQ: E, schema: Schema, encWildcardIndex: PropIndex<Wildcard<any>>, opt: QueryConfig): boolean;
}
export declare class EncodingConstraintModel<E extends EncodingQueryBase> extends AbstractConstraintModel {
    constructor(constraint: EncodingConstraint<E>);
    hasAllRequiredPropertiesSpecific(encQ: E): boolean;
    satisfy(encQ: E, schema: Schema, encWildcardIndex: PropIndex<Wildcard<any>>, opt: QueryConfig): boolean;
}
/** Constraint for a single encoding mapping */
export interface EncodingConstraint<E extends EncodingQueryBase> extends AbstractConstraint {
    /** Method for checking if the encoding query satisfies this constraint. */
    satisfy: EncodingConstraintChecker<E>;
}
export declare const FIELD_CONSTRAINTS: EncodingConstraintModel<FieldQuery>[];
export declare const FIELD_CONSTRAINT_INDEX: {
    [name: string]: EncodingConstraintModel<FieldQuery>;
};
export declare const VALUE_CONSTRAINTS: EncodingConstraintModel<ValueQuery>[];
export declare const VALUE_CONSTRAINT_INDEX: {
    [name: string]: EncodingConstraintModel<ValueQuery>;
};
/**
 * Check all encoding constraints for a particular property and index tuple
 */
export declare function checkEncoding(prop: Property, wildcard: Wildcard<any>, index: number, specM: SpecQueryModel, schema: Schema, opt: QueryConfig): string;
